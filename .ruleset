<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="">
    <description>PMD Plugin preferences rule set</description>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Explicit call of finalize method" name="ExplicitCallToFinalize">
        <description>
       An explicit call was made to a finalize method.  Finalize methods
       are meant to be executed at most once (by the garbage collector).
       Calling it explicitly could result in the method being executed
       twice for that object (once by you, once by the garbage collector).
       </description>
        <example><![CDATA[
   
public class Foo {
 public void close()  {
    finalize();       // this is bad
    foo.finalize();   // this is also bad
    this.finalize();  // this is bad but currently not flagged
    super.finalize(); // this is OK
    foo.finalize(3);  // this is arguably OK because the method is overloaded
 }
}
   
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

//PrimaryExpression[PrimarySuffix
 /Arguments[count(*) = 0]]
  /PrimaryPrefix
   /Name[@Image = 'finalize' or ends-with(@Image, '.finalize')]

                 ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.BeanMembersShouldSerializeRule" message="Found non-transient, non-static member. Please mark as transient or provide accessors." name="BeanMembersShouldSerialize" symboltable="true">
        <description>
If a class is a bean, or is referenced by a bean, directly or indirectly
it needs to be serializable. Member variables need to be marked as transient,
marked as static, or have accessor methods in the class. Marking variables
as transient is the safest and easiest modification. Accessor methods should
follow the Java naming conventions, i.e.if you have a variable foo, you should
provide getFoo and setFoo methods.
    </description>
        <example><![CDATA[

  private transient int someFoo;//good, it's transient
  private static int otherFoo;// also OK
  private int moreFoo;// OK, has proper accessors, see below
  private int badFoo;//bad, should be marked transient


  private void setMoreFoo(int moreFoo){
        this.moreFoo = moreFoo;
  }

  private int getMoreFoo(){
        return this.moreFoo;
  }


    ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid importing anything from the package 'java.lang'" name="DontImportJavaLang">
        <description>
    Avoid importing anything from the package 'java.lang'.  These classes are automatically imported (JLS 7.5.3).
    </description>
        <example><![CDATA[

// this is bad
import java.lang.String;
public class Foo {}

// --- in another source code file...

// this is bad
import java.lang.*;

public class Foo {}

    ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
//ImportDeclaration
 [starts-with(Name/@Image, 'java.lang')]
 [not(starts-with(Name/@Image, 'java.lang.ref'))]
 [not(starts-with(Name/@Image, 'java.lang.reflect'))]
                
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="You may have misspelled a JUnit framework method (setUp or tearDown)" name="JUnitSpelling">
        <description>
    Some JUnit framework methods are easy to misspell.
    </description>
        <example><![CDATA[

import junit.framework.*;
public class Foo extends TestCase {
 public void setup() {} // oops, should be setUp
 public void TearDown() {} // oops, should be tearDown
}

    ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
              
//MethodDeclarator[(not(@Image = 'setUp')
 and translate(@Image, 'SETuP', 'setUp') = 'setUp')
 or (not(@Image = 'tearDown')
 and translate(@Image, 'TEARdOWN', 'tearDown') = 'tearDown')]
 [FormalParameters[count(*) = 0]]
              
          ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.junit.JUnitTestsShouldContainAsserts" message="JUnit tests should include assert() or fail()" name="JUnitTestsShouldIncludeAssert">
        <description>
        JUnit assertions should include an assertion - This makes the tests more robust
            and assert() with messages provide the developer a clearer idea of what
        the test does.
        </description>
        <example><![CDATA[
    
    public class Foo extends TestCase {
      public void testSomething() {
          Bar b = findBar();
      // This is better than having a NullPointerException
      // assertNotNull("bar not found", b);
      b.work();
      }
    }
    
        ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Abstract classes should be named 'AbstractXXX'" name="AbstractNaming">
        <description>
  Abstract classes should be named 'AbstractXXX'.
       </description>
        <example><![CDATA[

public abstract class Foo { // should be AbstractFoo
}

       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    
//ClassDeclaration[@Abstract='true']
 /UnmodifiedClassDeclaration[starts-with(@Image,'Abstract') = 0]
                    
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.design.AssignmentToNonFinalStatic" message="Possible unsafe assignment to a non-final static field in a constructor." name="AssignmentToNonFinalStatic" symboltable="true">
        <description>
       Identifies a possible unsafe usage of a static field.
       </description>
        <example><![CDATA[
   
   public class StaticField {
       static int x;
 
       public FinalFields(int y) {
           x = y;
       }
 
   }
   Identifies the unasignment to x as possibly unsafe.
   
       ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid instantiating an object just to call getClass() on it; use the .class public member instead" name="InstantiationToGetClass">
        <description>
Avoid instantiating an object just to call getClass() on it; use the .class public member instead
      </description>
        <example><![CDATA[
    
class Foo {
 Class c = new String().getClass();
}
    
        ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                
//PrimarySuffix
 [@Image='getClass']
 [parent::PrimaryExpression
  [PrimaryPrefix/AllocationExpression]
  [count(PrimarySuffix) = 2]
 ]
     
            ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.ExcessiveImports" message="A high number of imports can indicate a high degree of coupling within an object." name="ExcessiveImports">
        <description>
      A high number of imports can indicate a high degree of coupling within
      an object. Rule counts the number of unique imports and reports a violation
      if the count is above the user defined threshold.
  </description>
        <example><![CDATA[
      
      import blah.blah.Bardo;
      import blah.blah.Hardo;
      import blah.blah.Bar;
      import blah.net.ObjectA;
      //imports over some threshold
      public class Foo {
        public void doWork() {}
      }
      
  ]]></example>
        <priority>3</priority>
        <properties>
            <property name="minimum" value="30"/>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.sunsecure.MethodReturnsInternalArray" message="Never return a reference to an internal array that contains sensitive data" name="MethodReturnsInternalArray">
        <description>
      Exposing internal arrays directly allows the user to modify some code that could be critical.
      It is safer to return a copy of the array.
      </description>
        <example><![CDATA[
  
  public class SecureSystem {
      UserData [] ud;
      
      public UserData [] getUserData() {
          // Don't return directly the internal array, return a copy 
          return ud;
      }
  }
  
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Classes should not have non-constructor methods with the same name as the class" name="MethodWithSameNameAsEnclosingClass">
        <description>
       Non-constructor methods should not have the same name as the enclosing class.
       </description>
        <example><![CDATA[
    
public class MyClass {
// this is bad because it is a method
public void MyClass() {}
// this is OK because it is a constructor
public MyClass() {}
}
    
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

//MethodDeclaration
 [parent::ClassBodyDeclaration
  [parent::ClassBody
   [parent::UnmodifiedClassDeclaration/@Image = //MethodDeclarator/@Image
   ]]]
 
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="When doing a String.toLowerCase()/toUpperCase() call, use a Locale" name="UseLocaleWithCaseConversions">
        <description>
When doing a String.toLowerCase()/toUpperCase() call, use a Locale.  This avoids
          problems with certain locales, i.e. Turkish.
      </description>
        <example><![CDATA[
    
class Foo {
 // BAD
 if (x.toLowerCase().equals("list"))...
 /*
 This will not match "LIST" when in Turkish locale
 The above could be
 if (x.toLowerCase(Locale.US).equals("list")) ...
 or simply
 if (x.equalsIgnoreCase("list")) ...
 */

 // GOOD
 String z = a.toLowerCase(Locale.EN);
}
    
        ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                
//PrimaryExpression
[PrimaryPrefix/Name
 [ends-with(@Image, 'toLowerCase') or ends-with(@Image,
'toUpperCase')]
 ]
[PrimarySuffix/Arguments[@ArgumentCount=0]]
     
            ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.ExcessivePublicCount" message="A high number of public methods and attributes in an object can indicate the class may need to be broken up for exhaustive testing may prove difficult." name="ExcessivePublicCount">
        <description>
    A large amount of public methods and attributes declared in an object can indicate the class may need
    to be broken up as increased effort will be required to thoroughly test such a class.
    </description>
        <example><![CDATA[
    

    public class Foo {
    public String value;
    public Bar something;
    public Variable var;
    //more public attributes
    public void doWork() {}
    public void doMoreWork() {}
    public void doWorkAgain() {}
    public void doWorking() {}
    public void doWorkIt() {}
    public void doWorkingAgain() {}
    public void doWorkAgainAgain() {}
    public void doWorked() {}

    }
    
    ]]></example>
        <priority>3</priority>
        <properties>
            <property name="minimum" value="45"/>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid using dollar signs in variable/method/class/interface names" name="AvoidDollarSigns">
        <description>
       Avoid using dollar signs in variable/method/class/interface names.
       </description>
        <example><![CDATA[
   
 public class Fo$o {  // yikes!
 }
   
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

//UnmodifiedClassDeclaration[contains(@Image, '$')]
|
//VariableDeclaratorId[contains(@Image, '$')]
|
//UnmodifiedInterfaceDeclaration[contains(@Image, '$')]
|
//MethodDeclarator[contains(@Image, '$')]
 
                 ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.junit.JUnitAssertionsShouldIncludeMessage" message="JUnit assertions should include a message" name="JUnitAssertionsShouldIncludeMessage">
        <description>
      JUnit assertions should include a message - i.e., use the three argument version of
          assertEquals(), not the two argument version.
      </description>
        <example><![CDATA[
  
  public class Foo extends TestCase {
    public void testSomething() {
        assertEquals("foo", "bar");
        // not good!  use the form:
        // assertEquals("Foo does not equals bar", "foo", "bar");
        // instead
    }
  }
  
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid using 'for' statements without curly braces" name="ForLoopsMustUseBraces">
        <description>
       Avoid using 'for' statements without using curly braces
       </description>
        <example><![CDATA[
   
     public void foo() {
       for (int i=0; i<42;i++)
           foo();
     }
   
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                     
    //ForStatement[not(Statement/Block)]
                     
                 ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="The method name and parameter number are suspiciously close to equals(Object)" name="SuspiciousEqualsMethodName">
        <description>
              The method name and parameter number are suspiciously close to
     equals(Object), which may mean you are trying (and failing) to override the equals(Object)
        method.
        </description>
        <example><![CDATA[
        
    public class Foo {
         public int equals(Object o) {
         // oops, this probably was supposed to be boolean equals
         }
         public boolean equals(String s) {
         // oops, this probably was supposed to be equals(Object)
         }
    }
        
        ]]></example>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
        
//MethodDeclarator [
(
@Image = 'equals'
  and count(FormalParameters/*) = 1
  and not (FormalParameters/FormalParameter/Type/Name
   [@Image = 'Object' or @Image = 'java.lang.Object'])
)
or
@Image='equal'
 and count(FormalParameters/*) = 1
 and (FormalParameters/FormalParameter/Type/Name
  [@Image = 'Object' or @Image = 'java.lang.Object'])

]
        
                    ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.strictexception.AvoidCatchingThrowable" message="A catch statement should never catch throwable since it includes errors" name="AvoidCatchingThrowable">
        <description>
This is dangerous because if a java.lang.Error, for example OutOfMemmoryError,
occurs then it will be caught. The container should handle java.lang.Error.
If application code will catch them, try to log them (which will probably fail)
and continue silently the situation will not be desirable.
      </description>
        <example><![CDATA[
                
SimpleDateFormat sdf = null;
try {
    sdf = new SimpleDateFormat("yyyy-MM-dd");
} catch (Throwable th) {  //Should not catch throwable
    th.printStackTrace();
}
                
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.design.ExceptionAsFlowControl" message="Avoid using exceptions as flow control" name="ExceptionAsFlowControl">
        <description>
          Using Exceptions as flow control leads to GOTOish code.
      </description>
        <example><![CDATA[
  
  public class Foo {
   void bar() {
    try {
     try {
     } catch (Exception e) {
      throw new WrapperException(e);
      // this is essentially a GOTO to the WrapperException catch block
     }
    } catch (WrapperException e) {
     // do some more stuff
    }
   }
  }
  
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="This final field could be made static" name="FinalFieldCouldBeStatic">
        <description>
      If a final field is assigned to a compile-time constant, it could be
          made static, thus saving overhead in each object
      </description>
        <example><![CDATA[
  
public class Foo {
 public final int BAR = 42; // this could be static and save some space
}
  
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    
//FieldDeclaration
 [not (ancestor::InterfaceDeclaration)]
  [@Final='true' and @Static='false']
   /VariableDeclarator/VariableInitializer/Expression
    /PrimaryExpression/PrimaryPrefix/Literal
                    
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="The method name and return type are suspiciously close to hashCode()" name="SuspiciousHashcodeMethodName">
        <description>
       The method name and return type are suspiciously close to hashCode(), which
       may mean you are trying (and failing) to override the hashCode() method.
       </description>
        <example><![CDATA[
    
public class Foo {
 public int hashcode() {
 // oops, this probably was supposed to be hashCode
 }
}
    
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

//MethodDeclaration
 [ResultType
  //PrimitiveType
   [@Image='int']
   [//MethodDeclarator
    [@Image='hashcode' or @Image='HashCode' or @Image='Hashcode']
    [not(FormalParameters/*)]

                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid modifiers which are implied by the context" name="UnusedModifier">
        <description>
     Fields in interfaces are automatically public static final, and
     methods are public abstract.
     Classes or interfaces nested in an interface are automatically public
     and static (all nested interfaces are automatically static).
     For historical reasons, modifiers which are implied by the context
     are accepted by the compiler, but are superfluous.
     </description>
        <example><![CDATA[
 
    public interface Foo {
     public abstract void bar(); // both abstract and public are ignored by the compiler
     public static final int X = 0; // public, static, and final all ignored
     public static class Bar {} // public, static ignored
     public static interface Baz {} // ditto
    }
    public class Bar {
     public static interface Baz {} // static ignored
    }
 
     ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    
    //UnmodifiedInterfaceDeclaration//MethodDeclaration
      [@Public = 'true' or @Abstract = 'true']
      [count(//Block) = 0]
       [not (parent::ClassBodyDeclaration
        [parent::ClassBody
         [parent::UnmodifiedClassDeclaration
          [parent::NestedClassDeclaration]
         ]
        ]
       )]
|   //UnmodifiedInterfaceDeclaration//FieldDeclaration
    [@Public = 'true' or @Static = 'true' or @Final = 'true']
    [not (parent::ClassBodyDeclaration
     [parent::ClassBody
      [parent::UnmodifiedClassDeclaration
       [parent::NestedClassDeclaration]
      ]
     ]
    )]
|   //UnmodifiedInterfaceDeclaration//NestedClassDeclaration[@Public = 'true' or @Static = 'true']
|   //UnmodifiedInterfaceDeclaration//NestedInterfaceDeclaration[@Public = 'true' or @Static = 'true']
|   //UnmodifiedClassDeclaration//NestedInterfaceDeclaration[@Static = 'true']
                    
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod" message="Avoid calls to overridable methods during construction" name="ConstructorCallsOverridableMethod">
        <description>
      Calling overridable methods during construction poses a risk of invoking methods on an
          incompletely constructed object.  This situation can be difficult to discern.
      It may leave the sub-class unable to construct its superclass or forced to
          replicate the construction process completely within itself, losing the ability to call
      super().  If the default constructor contains a call to an overridable method,
          the subclass may be completely uninstantiable.   Note that this includes method calls
          throughout the control flow graph - i.e., if a constructor Foo() calls a private method
            bar() that calls a public method buz(), there's a problem.
      </description>
        <example><![CDATA[
  
    public class SeniorClass {
      public SeniorClass(){
          toString(); //may throw NullPointerException if overridden
      }
      public String toString(){
        return "IAmSeniorClass";
      }
    }
    public class JuniorClass extends SeniorClass {
      private String name;
      public JuniorClass(){
        super(); //Automatic call leads to NullPointerException
        name = "JuniorClass";
      }
      public String toString(){
        return name.toUpperCase();
      }
    }
  
      ]]></example>
        <priority>1</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Non-static initializers are confusing" name="NonStaticInitializer">
        <description>
       A nonstatic initializer block will be called any time a constructor
       is invoked (just prior to invoking the constructor).  While this
       is a valid language construct, it is rarely used and is confusing.
       </description>
        <example><![CDATA[
   
public class MyClass {
 // this block gets run before any call to a constructor
 {
  System.out.println("I am about to construct myself");
 }
}
   
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

//ClassBodyDeclaration/Initializer[not(@Static='true')]

                 ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.UnusedLocalVariableRule" message="Avoid unused local variables such as ''{0}''" name="UnusedLocalVariable" symboltable="true">
        <description>
Detects when a local variable is declared and/or assigned, but not used.
    </description>
        <example><![CDATA[

public void doSomething() {
  int i = 5; // Unused
}

    ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.design.SwitchDensityRule" message="A high ratio of statements to labels in a switch statement.  Consider refactoring." name="SwitchDensity">
        <description>
 A high ratio of statements to labels in a switch statement implies that the switch
 statement is doing too much work.  Consider moving the statements either into new
 methods, or creating subclasses based on the switch variable.
      </description>
        <example><![CDATA[
 
   public class Foo {
     private int x;
     public void bar() {
       switch (x) {
         case 1: {
           System.out.println("I am a fish.");
           System.out.println("I am a fish.");
           System.out.println("I am a fish.");
           System.out.println("I am a fish.");
           break;
         }

         case 2: {
           System.out.println("I am a cow.");
           System.out.println("I am a cow.");
           System.out.println("I am a cow.");
           System.out.println("I am a cow.");
           break;
         }
       }
     }
   }
 
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="minimum" value="10"/>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.strictexception.ExceptionTypeChecking" message="The catch clause shouldn't check the exception type - catch several exceptions instead" name="ExceptionTypeChecking">
        <description>
At some places Exception is caught and then a check with instanceof is performed.
This result in messy code. It's considered better to catch all the specific
exceptions instead.
      </description>
        <example><![CDATA[
                
SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
try {
    returnString = sdf.format(value);
} catch (Exception ex) {
    /* BAD STUFF !!!*/
    if (ex instanceof NumberFormatException) {
        System.out.println("NumberFormat exception!!!");
    }
    if (ex instanceof IllegalArgumentException) {
        System.out.println("illegal argument...!!!");
    }
}
                
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid empty finally blocks" name="EmptyFinallyBlock">
        <description>
  Avoid empty finally blocks - these can be deleted.
      </description>
        <example><![CDATA[
  // this is bad
  public void bar() {
      try {
          int x=2;
      } finally {
      }
  }
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  //TryStatement[@Finally='true']/Block[position() = last()]
      [count(*) = 0]
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Class contains more than one Logger" name="MoreThanOneLogger">
        <description>
     Normally only one logger is used in each class.
     </description>
        <example><![CDATA[
 
class Foo{
    Logger log = Logger.getLogger(Foo.class.getName());
    // It is very rare to see two loggers on a class, normally 
    // log information is multiplexed by levels
    Logger log2= Logger.getLogger(Foo.class.getName());
}

     ]]></example>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                 
//ClassBody[
	count(//VariableDeclarator[../Type/Name[@Image='Logger']])
	>1
	]
                
             ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid returning from a finally block" name="ReturnFromFinallyBlock">
        <description>
  Avoid returning from a finally block - this can discard exceptions.
      </description>
        <example><![CDATA[
  public class Bar {
 public String bugga() {
  try {
   throw new Exception( "My Exception" );
  } catch (Exception e) {
   throw e;
  } finally {
   return "A. O. K."; // Very bad.
  }
 }
}
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  //TryStatement[@Finally='true']/Block[position() = last()]//ReturnStatement
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.CyclomaticComplexity" message="The {0} ''{1}'' has a Cyclomatic Complexity of {2}." name="CyclomaticComplexity">
        <description>
Complexity is determined by the number of decision points in a method plus one for the
method entry.  The decision points are 'if', 'while', 'for', and 'case labels'.  Scale:
1-4 (low complexity)   5-7 (moderate complexity)   8-10 (high complexity)   10+ (very high complexity)
   </description>
        <example><![CDATA[

Cyclomatic Complexity = 12

public class Foo
{
1   public void example()
    {
2       if (a == b)
        {
3           if (a1 == b1)
            {
                do something;
            }
4           else if a2 == b2)
            {
                do something;
            }
            else
            {
                do something;
            }
        }
5       else if (c == d)
        {
6           while (c == d)
            {
                do something;
            }
        }
7       else if (e == f)
        {
8           for (int n = 0; n < h; n++)
            {
                do something;
            }
        }
        else
        {
            switch (z)
            {
9               case 1:
                    do something;
                    break;

10              case 2:
                    do something;
                    break;

11              case 3:
                    do something;
                    break;

12              default:
                    do something;
                    break;
            }
        }
    }
}

   ]]></example>
        <priority>3</priority>
        <properties>
            <property name="reportLevel" value="10"/>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.StringToStringRule" message="Avoid calling toString() on String objects; this is unnecessary" name="StringToString" symboltable="true">
        <description>
    Avoid calling toString() on String objects; this is unnecessary
    </description>
        <example><![CDATA[

public class Foo {
 private String baz() {
  String bar = "howdy";
  return bar.toString();
 }
}

    ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.UnusedImportsRule" message="Avoid unused imports such as ''{0}''" name="UnusedImports">
        <description>
    Avoid unused import statements.
    </description>
        <example><![CDATA[

// this is bad
import java.io.File;
public class Foo {}

    ]]></example>
        <priority>4</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="clone() method should be implemented only if implementing Cloneable interface" name="CloneMethodMustImplementCloneable">
        <description>
       The method clone() should only be implemented if the class implements Cloneable interface
        </description>
        <example><![CDATA[
            
public class MyClass  {
   // will cause an error
   public Object clone() throws CloneNotSupportedException {
    ...
   }
}
   
        ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    
//ClassDeclaration
[not(./UnmodifiedClassDeclaration/NameList/Name
[contains(@Image, 'Cloneable')])]
[.//MethodDeclaration/MethodDeclarator[@Image
= 'clone' and count(FormatParameters/*) = 0]]
                    
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid empty try blocks" name="EmptyTryBlock">
        <description>
  Avoid empty try blocks - what's the point?
      </description>
        <example><![CDATA[
  // this is bad
  public void bar() {
      try {
      } catch (Exception e) {
          e.printStackTrace();
      }
  }
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  //TryStatement/Block[1][count(*) = 0]
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="An empty statement (semicolon) not part of a loop" name="EmptyStatementNotInLoop">
        <description>
       An empty statement (aka a semicolon by itself) that is not used
       as the sole body of a for loop or while loop is probably a bug.  It
       could also be a double semicolon, which is useless and should be
       removed.
       </description>
        <example><![CDATA[
public class MyClass {
   public void doit()
   {
      // this is probably not what you meant to do
      ;
      // the extra semicolon here this is not necessary
      System.out.println("look at the extra semicolon");;
   }
}
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//Statement/EmptyStatement
 [not(
       ../../../ForStatement
       or ../../../WhileStatement
       or ../../../BlockStatement/UnmodifiedClassDeclaration
       or ../../../../../../ForStatement/Statement[1]
        /Block[1]/BlockStatement[1]/Statement/EmptyStatement
       or ../../../../../../WhileStatement/Statement[1]
        /Block[1]/BlockStatement[1]/Statement/EmptyStatement)
 ]

                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="The default label should be the last label in a switch statement" name="DefaultLabelNotLastInSwitchStmt">
        <description>
       The default label in a switch statement should be the last label, by convention.
       Most programmers will expect the default label (if present) to be the last one.
       </description>
        <example><![CDATA[
   
      switch (a)
      {
         case 1:
            // do something
            break;
         default:
            // the default case should be last, by convention
            break;
         case 2:
            break;
      }
   
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

//SwitchStatement
 [not(SwitchLabel[position() = last()][count(*) = 0])]
 [SwitchLabel[count(*) = 0]

                 ]]></value>
            </property>
        </properties>
    </rule>
    <!--*removed*<rule class="net.sourceforge.pmd.rules.XPathRule" message="Each class should declare at least one constructor" name="AtLeastOneConstructor">
        <description>
  Each class should declare at least one constructor.
  </description>
        <example><![CDATA[
  
  public class Foo {
   // no constructor!  not good!
  }
  
  ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

//UnmodifiedClassDeclaration[not(ClassBody/ClassBodyDeclaration/ConstructorDeclaration)]

                ]]></value>
            </property>
        </properties>
    </rule>-->
    <rule class="net.sourceforge.pmd.rules.strictexception.ExceptionSignatureDeclaration" message="A signature (constructor or method) shouldn't have Exception in throws declaration" name="SignatureDeclareThrowsException">
        <description>
It is unclear which exceptions that can be thrown from the methods.
It might be difficult to document and understand the vague interfaces.
Use either a class derived from RuntimeException or a checked exception.
      </description>
        <example><![CDATA[
                
public void methodThrowingException() throws Exception {
}
                
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.UnusedPrivateFieldRule" message="Avoid unused private fields such as ''{0}''" name="UnusedPrivateField" symboltable="true">
        <description>
Detects when a private field is declared and/or assigned a value, but not used.
    </description>
        <example><![CDATA[

public class Something {
  private static int FOO = 2; // Unused
  private int i = 5; // Unused
  private int j = 6;
  public int addOne() {
    return j++;
  }
}

    ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.AccessorClassGeneration" message="Avoid instantiation through private constructors from outside of the constructor's class." name="AccessorClassGeneration">
        <description>
      Instantiation by way of private constructors from outside of the constructor's class often causes the generation of an accessor.
      A factory method, or non-privitization of the constructor can eliminate this situation.
      The generated class file is actually an interface.  It gives the accessing class the ability to invoke a new hidden package
      scope constructor that takes the interface as a supplementary parameter.  This turns a private constructor effectively into
      one with package scope, though not visible to the naked eye.
      </description>
        <example><![CDATA[
  
  public class OuterClass {
    void method(){
      InnerClass ic = new InnerClass();//Causes generation of accessor
    }
    public class InnerClass {
      private InnerClass(){
      }
    }
  }

  public class OuterClass {
    void method(){
      InnerClass ic = new InnerClass();//OK, due to public constructor
    }
    public class InnerClass {
      public InnerClass(){
      }
    }
  }

  public class OuterClass {
    void method(){
      InnerClass ic = InnerClass.getInnerClass();//OK
    }
    public static class InnerClass {
      private InnerClass(){
      }
      private static InnerClass getInnerClass(){
        return new InnerClass();
      }
    }
  }

  public class OuterClass {
    private OuterClass(){
    }
    public class InnerClass {
      void method(){
        OuterClass oc = new OuterClass();//Causes generation of accessor
      }
    }
  }
  
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.AvoidReassigningParameters" message="Avoid reassigning parameters such as ''{0}''" name="AvoidReassigningParameters" symboltable="true">
        <description>
Reassigning values to parameters is a questionable practice.  Use a temporary local variable instead.
    </description>
        <example><![CDATA[

public class Foo {
 private void foo(String bar) {
  bar = "something else";
 }
}

    ]]></example>
        <priority>2</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.design.LongMethodRule" message="Avoid really long methods." name="ExcessiveMethodLength">
        <description>
Excessive Method Length usually means that the method is doing
too much.  There is usually quite a bit of Cut and Paste there
as well.  Try to reduce the method size by creating helper methods,
and removing cut and paste.

Default value is 2.5 sigma greater than the mean.

There are three parameters available:
minimum - Minimum Length before reporting.
sigma - Std Deviations away from the mean before reporting.
topscore - The Maximum Number of reports to generate.

At this time, only one can be used at a time.

   </description>
        <example><![CDATA[

public void doSomething() {
  System.out.println("I am a fish.");
  System.out.println("I am a fish.");
  System.out.println("I am a fish.");
  System.out.println("I am a fish.");
  System.out.println("I am a fish.");
  // 495 copies omitted for brevity.
}

   ]]></example>
        <priority>3</priority>
        <properties>
            <property name="minimum" value="100"/>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.ImportFromSamePackageRule" message="No need to import a type that's in the same package" name="ImportFromSamePackage">
        <description>
     No need to import a type that's in the same package.
     </description>
        <example><![CDATA[
 
 package foo;
 import foo.Buz; // no need for this
 public class Bar{}
 
     ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.CouplingBetweenObjects" message="High amount of different objects as memebers donotes a high coupling" name="CouplingBetweenObjects" symboltable="true">
        <description>
        Rule counts unique attributes, local variables and return types within an object. An amount
        higher than specified threshold can indicate a high degree of couping with in an object
    </description>
        <example><![CDATA[
    
      import com.Blah;
      import org.Bar;
      import org.Bardo;
      //
      public class Foo {
        private Blah var1;
        private Bar var2;
        //followed by many imports of unique objects

        void ObjectC doWork() {
           Bardo var55;
           ObjectA var44;
           ObjectZ var93;
           return something;
        }

        }
        
    ]]></example>
        <priority>3</priority>
        <properties>
            <property name="threshold" value="20"/>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.IdempotentOperations" message="Avoid idempotent operations (like assigning a variable to itself)" name="IdempotentOperations">
        <description>
      Avoid idempotent operations - they are silly.
      </description>
        <example><![CDATA[
      
    public class Foo {
     public void bar() {
      int x = 2;
      x = x;
     }
    }
      
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.MethodNamingConventions" message="Method name does not begin with a lower case character." name="MethodNamingConventions">
        <description>
              Method names should always begin with a lower case character, and should not contain underscores.
          </description>
        <example><![CDATA[

public class Foo {
        public void fooStuff() {
        }
}

          ]]></example>
        <priority>1</priority>
        <properties/>
    </rule>
    <!--*removed*<rule class="net.sourceforge.pmd.rules.design.OnlyOneReturnRule" message="A method should have only one exit point, and that should be the last statement in the method" name="OnlyOneReturn">
        <description>
     A method should have only one exit point, and that should be the last statement in the method.
     </description>
        <example><![CDATA[
 
 public class OneReturnOnly1 {
  public void foo(int x) {
   if (x > 0) {
    return "hey";   // oops, multiple exit points!
   }
   return "hi";
  }
 }
 
     ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>-->
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Ensure you override both equals() and hashCode()" name="OverrideBothEqualsAndHashcode">
        <description>
  Override both public boolean Object.equals(Object other), and public int Object.hashCode(), or override neither.  Even if you are inheriting a hashCode() from a parent class, consider implementing hashCode and explicitly delegating to your superclass.
      </description>
        <example><![CDATA[
  // this is bad
  public class Bar {
      public boolean equals(Object o) {
          // do some comparison
      }
  }

  // and so is this
  public class Baz {
      public int hashCode() {
          // return some hash value
      }
  }

  // this is OK
  public class Foo {
      public boolean equals(Object other) {
          // do some comparison
      }
      public int hashCode() {
          // return some hash value
      }
  }
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ClassDeclaration//MethodDeclarator
[(@Image = 'equals' and count(FormalParameters/*) = 1
and not(//MethodDeclarator[count(FormalParameters/*) = 0][@Image = 'hashCode']))
or
(@Image='hashCode' and count(FormalParameters/*) = 0
and
not
(//MethodDeclarator
 [count(
   FormalParameters//Type/Name
    [@Image = 'Object' or @Image = 'java.lang.Object']) = 1]
    [@Image = 'equals']))]
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.DuplicateImportsRule" message="Avoid duplicate imports such as ''{0}''" name="DuplicateImports">
        <description>
    Avoid duplicate import statements.
    </description>
        <example><![CDATA[

// this is bad
import java.io.File;
import java.io.File;
public class Foo {}

// --- in another source code file...

// this is bad
import java.io.*;
import java.io.File;

public class Foo {}

    ]]></example>
        <priority>4</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.UnnecessaryConversionTemporary" message="Avoid unnecessary temporaries when converting primitives to Strings" name="UnnecessaryConversionTemporary">
        <description>
      Avoid unnecessary temporaries when converting primitives to Strings
      </description>
        <example><![CDATA[
  public String convert(int x) {
      // this wastes an object
      String foo = new Integer(x).toString();
      // this is better
      return Integer.toString(x);
    }
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="clone() method should throw CloneNotSupportedException" name="CloneThrowsCloneNotSupportedException">
        <description>
        The method clone() should throw a CloneNotSupportedException
         </description>
        <example><![CDATA[
             
 public class MyClass implements Cloneable{
     public Object clone() // will cause an error {
          MyClass clone = (MyClass)super.clone();
          ...
          return clone;
     }
 }
    
         ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                     
//ClassDeclaration
[@Final = 'false']
[.//MethodDeclaration[
MethodDeclarator/@Image = 'clone'
and count(MethodDeclarator/FormalParameters/*) = 0
and count(NameList/Name[contains
(@Image,'CloneNotSupportedException')]) = 0]]
                     
                 ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.design.LooseCoupling" message="Avoid using implementation types like ''{0}''; use the interface instead" name="LooseCoupling">
        <description>
      Avoid using implementation types (i.e., HashSet); use the interface (i.e, Set) instead
      </description>
        <example><![CDATA[
  
  import java.util.*;
  public class Bar {

   // should be "private List list"
   private ArrayList list = new ArrayList();

   // should be "public Set getFoo()"
   public HashSet getFoo() {
    return new HashSet();
   }
  }

  
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="A non-case label was present in a switch statement" name="NonCaseLabelInSwitchStatement">
        <description>
       A non-case label (e.g. a named break/continue label) was present in a switch statement.
       This legal, but confusing. It is easy to mix up the case labels and the non-case labels.
       </description>
        <example><![CDATA[
   
public class Foo {
 void bar(int a) {
  switch (a)
  {
   case 1:
      // do something
      break;
   mylabel: // this is legal, but confusing!
      break;
   default:
      break;
  }
 }
}
   
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
 
    //SwitchStatement//BlockStatement/Statement/LabeledStatement
 
                 ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid unnecessary comparisons in boolean expressions" name="SimplifyBooleanExpressions">
        <description>
  Avoid unnecessary comparisons in boolean expressions - this makes simple code seem complicated.
      </description>
        <example><![CDATA[
  
public class Bar {
 // can be simplified to
 // bar = isFoo();
 private boolean bar = (isFoo() == true);

 public isFoo() { return false;}
}
  
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

//EqualityExpression/PrimaryExpression/PrimaryPrefix/Literal/BooleanLiteral

              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid assigments in operands" name="AssignmentInOperand">
        <description>
  Avoid assigments in operands; this can make code more complicated and harder to read.
  </description>
        <example><![CDATA[
  
  public class Foo {
   public void bar() {
int x = 2;
if ((x = getX()) == 3) {
 System.out.println("3!");
}
   }
   private int getX() {
return 3;
   }
  }

  
  ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    
//*[name()='WhileStatement' or name()='IfStatement'][Expression//AssignmentOperator]
                    
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid unnecessary constructors - the compiler will generate these for you" name="UnnecessaryConstructor">
        <description>
  Unnecessary constructor detects when a constructor is not necessary; i.e., when there's only one constructor,
  it's public, has an empty body, and takes no arguments.
      </description>
        <example><![CDATA[
  
  public class Foo {
   public Foo() {}
  }
  
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    
//UnmodifiedClassDeclaration
/ClassBody[count(ClassBodyDeclaration/ConstructorDeclaration)=1]
/ClassBodyDeclaration/ConstructorDeclaration
[@Public='true']
[not(FormalParameters/*)]
[not(BlockStatement)]
[not(NameList)]
[count(ExplicitConstructorInvocation/Arguments/ArgumentList/Expression)=0]
                    
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.design.LongClassRule" message="Avoid really long Classes." name="ExcessiveClassLength">
        <description>
Long Class files are indications that the class may be trying to
do too much.  Try to break it down, and reduce the size to something
managable.

Default value is 2.5 sigma greater than the mean.

NOTE:  In version 0.9 and higher, their are three parameters available:
minimum - Minimum Length before reporting.
sigma - Std Deviations away from the mean before reporting.
topscore - The Maximum Number of reports to generate.

At this time, only one can be used at a time.

   </description>
        <example><![CDATA[

public class Foo {
  public void bar() {
    // 500 lines of code
  }

  public void baz() {
    // 500 more lines of code
  }
}

   ]]></example>
        <priority>3</priority>
        <properties>
            <property name="minimum" value="1000"/>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.sunsecure.ArrayIsStoredDirectly" message="A user given array is stored directly" name="ArrayIsStoredDirectly">
        <description>
      Constructors and methods receiving arrays shuold clone objects and store the copy.
      This prevents that future changes from the user affect the internal functionallity.
      </description>
        <example><![CDATA[
  
  public class Foo {
  private String [] x;
  
      public void foo (String [] param) {
          // Don't do this, make a copy of the array at least
          this.x=param;
      }
  }
  
  
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Object clone() should be implemented with super.clone()" name="ProperCloneImplementation">
        <description>
     Object clone() should be implemented with super.clone()
     </description>
        <example><![CDATA[
 
class Foo{
    public Object clone(){
        return new Foo(); // This is bad
    }
}

     ]]></example>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                 
//ClassDeclaration//MethodDeclarator
[@Image = 'clone']
[count(FormalParameters/*) = 0]
[count(../Block//*[
    (self::AllocationExpression) and
    (./Name/@Image = ancestor::
UnmodifiedClassDeclaration[position()=last()]/@Image)
  ])> 0
]
                
             ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="If you override finalize(), make it protected" name="FinalizeShouldBeProtected">
        <description>
      If you override finalize(), make it protected.  Otherwise, subclasses
          may not called your implementation of finalize.
      </description>
        <example><![CDATA[
  
public class Foo {
 public void finalize() {
  // do something
 }
}
  
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    
//MethodDeclaration[@Protected="false"]
  /MethodDeclarator[@Image="finalize"]
  [not(FormalParameters/*)]
                    
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.SimplifyBooleanReturns" message="Avoid unnecessary if..then..else statements when returning a boolean" name="SimplifyBooleanReturns">
        <description>
Avoid unnecessary if..then..else statements when returning a boolean
    </description>
        <example><![CDATA[

public class Foo {
  private int bar =2;
  public boolean isBarEqualsTo(int x) {
    // this bit of code
    if (bar == x) {
     return true;
    } else {
     return false;
    }
    // can be replaced with a simple
    // return bar == x;
  }
}

    ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.design.ConfusingTernary" message="Avoid if (x != y) ..; else ..;" name="ConfusingTernary">
        <description>
          In an "if" expression with an "else" clause, avoid negation in
          the test.  For example, rephrase:
            if (x != y) diff(); else same();
          as:
            if (x == y) same(); else diff();
          Most "if (x != y)" cases without an "else" are often return
          cases, so consistent use of this rule makes the code easier
          to read.  Also, this resolves trivial ordering problems, such
          as "does the error case go first?" or "does the common case
          go first?".
        </description>
        <example><![CDATA[
          
          return (x != y) ? diff : same;
          
        ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid unnecessary return statements" name="UnnecessaryReturn">
        <description>
  Avoid unnecessary return statements
      </description>
        <example><![CDATA[
  // this is bad
  public void bar() {
      int x = 42;
      return;
  }
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
 //ReturnStatement
 [parent::Statement
  [parent::BlockStatement
   [parent::Block
    [parent::MethodDeclaration/ResultType[@Void='true']
    ]
   ]
  ] 
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="The Logger variable declaration does not contain the static and final modifiers" name="LoggerIsNotStaticFinal">
        <description>
     In most cases, the Logger can be declared static and final.
     </description>
        <example><![CDATA[
 
class Foo{
    Logger log = Logger.getLogger(Foo.class.getName());
    // It is much better to declare the logger as follows 
    // static final Logger log = Logger.getLogger(Foo.class.getName());
}

     ]]></example>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                 
//VariableDeclarator[../Type/Name[@Image='Logger'] and (..[@Final='false'] or ..[@Static = 'false'] ) ]
                
             ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.VariableNamingConventions" message="{0} variable {1} should begin with {2}" name="VariableNamingConventions">
        <description>
    A variable naming conventions rule - customize this to your liking
    Final variables should be all caps
    Non-final variables should not include underscores
        </description>
        <example><![CDATA[

public class Foo {
    public static final int MY_NUM = 0;
    public String myTest = "";
    DataModule dmTest = new DataModule();
}

        ]]></example>
        <priority>1</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid importing anything from the 'sun.*' packages" name="DontImportSun">
        <description>
          Avoid importing anything from the 'sun.*' packages.  These packages are not portable and are likely to change.
       </description>
        <example><![CDATA[

   import sun.misc.foo;
   public class Foo {}

       ]]></example>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

   //ImportDeclaration
   [starts-with(Name/@Image, 'sun.')]
   [not(starts-with(Name/@Image, 'sun.misc.Signal'))]


               ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.SuspiciousOctalEscape" message="Suspicious decimal characters following octal escape in string literal" name="SuspiciousOctalEscape">
        <description>
      A suspicious octal escape sequence was found inside a String literal.
      The Java language specification (section 3.10.6) says an octal
      escape sequence inside a literal String shall consist of a backslash
      followed by:

           OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit OctalDigit

      Any octal escape sequence followed by non-octal digits can be confusing,
      e.g. "\038" is interpreted as the octal escape sequence "\03" followed by
      the literal character "8".
      </description>
        <example><![CDATA[

 public class Foo {
    public void foo() {
       // interpreted as octal 12, followed by character '8'
       System.out.println("suspicious: \128");
    }
 }

      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid empty catch blocks" name="EmptyCatchBlock">
        <description>
  Empty Catch Block finds instances where an exception is caught,
  but nothing is done.  In most circumstances, this swallows an exception
  which should either be acted on or reported.
      </description>
        <example><![CDATA[
  public void doSomething() {
      try {
        FileInputStream fis = new FileInputStream("/tmp/bugger");
      } catch (IOException ioe) {
          // not good
      }
    }
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
    //TryStatement
    [@Catch='true']
    [FormalParameter/Type/Name[@Image != 'InterruptedException' and @Image != 'CloneNotSupportedException']]
    /Block[position() > 1]
    [count(*) = 0]
    [../@Finally='false' or following-sibling::Block]
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="This for loop could be simplified to a while loop" name="ForLoopShouldBeWhileLoop">
        <description>
      Some for loops can be simplified to while loops - this makes them more concise.
      </description>
        <example><![CDATA[
  public class Foo {
      void bar() {
          for (;true;) true; // No Init or Update part, may as well be: while (true)
      }
  }
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                //ForStatement[count(*) > 1][not(ForInit)][not(ForUpdate)]
            ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="The field name indicates a constants but its modifiers don't" name="SuspiciousConstantFieldName">
        <description>
       A field name is all in uppercase characters, which in sun's java naming 
       conventions indicate a constant. However, the field is not final.
       </description>
        <example><![CDATA[
    
public class Foo {
	// this is bad, since someone could accidentally 
	// do PI = 2.71828; which is actualy e
	// final double PI = 3.16; is ok
	double PI = 3.16;
	
}
    
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

//FieldDeclaration
 [@Final='false']
 [parent::ClassBodyDeclaration]
 //VariableDeclarator/VariableDeclaratorId[upper-case(@Image)=@Image]

                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.AvoidDuplicateLiteralsRule" message="The String literal {0} appears {1} times in this file; the first occurrence is on line {2}" name="AvoidDuplicateLiterals">
        <description>
Code containing duplicate String literals can usually be improved by declaring the String as a constant field.
    </description>
        <example><![CDATA[

public class Foo {
 private void bar() {
    buz("Howdy");
    buz("Howdy");
    buz("Howdy");
    buz("Howdy");
 }
 private void buz(String x) {}
}

    ]]></example>
        <priority>3</priority>
        <properties>
            <property name="threshold" value="4"/>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.UnusedPrivateMethodRule" message="Avoid unused private methods such as ''{0}''" name="UnusedPrivateMethod">
        <description>
Unused Private Method detects when a private method is declared but is unused.
    </description>
        <example><![CDATA[

public class Something {
 private void foo() {} // unused
}

    ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Empty static initializer was found" name="EmptyStaticInitializer">
        <description>
       An empty static initializer was found.
       </description>
        <example><![CDATA[
   public class Foo {
  // why are there no statements in this static block?
  static {}
 }
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ClassBodyDeclaration/Initializer[@Static='true']/Block[count(*)=0]
                 ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Finalize should do something besides just calling super.finalize()" name="FinalizeOnlyCallsSuperFinalize">
        <description>
       If the finalize() is implemented, it should do something besides just calling
       super.finalize().
       </description>
        <example><![CDATA[
           
   public class Foo {
       protected void finalize() {
         super.finalize();
       }
   }
           
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

   //MethodDeclaration[MethodDeclarator[@Image="finalize"][not(FormalParameters/*)]]
       /Block[count(BlockStatement)=1]
         /BlockStatement[Statement/StatementExpression/PrimaryExpression
          /PrimaryPrefix[@Image="finalize"]

                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="This call to Collection.toArray() may be optimizable" name="OptimizableToArrayCall">
        <description>
  A call to Collection.toArray can use the Collection's size vs an empty Array of the desired type.
      </description>
        <example><![CDATA[
  
class Example {
 void bar() {
   // A bit inefficient, unlike...
   x.toArray(new Foo[0]);

   // ..this one, which sizes the destination array, avoiding
   // a reflection call in some Collection implementations
   x.toArray(new Foo[x.size()]);
}
}  
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
//PrimaryExpression
[PrimaryPrefix/Name[ends-with(@Image, 'toArray')]]
[
PrimarySuffix/Arguments/ArgumentList/Expression
 /PrimaryExpression/PrimaryPrefix/AllocationExpression
 /ArrayDimsAndInits/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image='0']
]

                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid using if statements without curly braces" name="IfStmtsMustUseBraces">
        <description>
     Avoid using if statements without using curly braces
     </description>
        <example><![CDATA[
 
 public class Foo {
   public void bar() {
     int x = 0;
     if (foo) x++;
   }
 }
 
     ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                   
    //IfStatement[count(*) < 3][not(Statement/Block)]
                   
               ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid empty 'while' statements" name="EmptyWhileStmt">
        <description>
  Empty While Statement finds all instances where a while statement
  does nothing.  If it is a timing loop, then you should use Thread.sleep() for it; if
  it's a while loop that does a lot in the exit expression, rewrite it to make it clearer.
       </description>
        <example><![CDATA[
  while (a == b) {
    // not good
  }
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  //WhileStatement/Statement/Block[count(*) = 0]
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="You have a suite() method that is not both public and static, so JUnit won't call it to get your TestSuite.  Is that what you wanted to do?" name="JUnitStaticSuite">
        <description>
      The suite() method in a JUnit test needs to be both public and static.
      </description>
        <example><![CDATA[
  
  import junit.framework.*;
  public class Foo extends TestCase {
   public void suite() {} // oops, should be static
   private static void suite() {} // oops, should be public
  }
  
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                
  //MethodDeclaration[not(@Static='true') or not(@Public='true')]
   [MethodDeclarator/@Image='suite']
   [MethodDeclarator/FormalParameters/@ParameterCount=0]
                
            ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid empty finalize methods" name="EmptyFinalizer">
        <description>
       If the finalize() method is empty, then it does not need to exist.
       </description>
        <example><![CDATA[

   public class Foo {
       protected void finalize() {}
   }

       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

   //MethodDeclaration[MethodDeclarator[@Image='finalize'][not(FormalParameters/*)]]
      /Block[count(*)=0]

                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid modifying an outer loop incrementer in an inner loop for update expression" name="JumbledIncrementer">
        <description>
     Avoid jumbled loop incrementers - it's usually a mistake, and it's confusing even if it's what's intended.
     </description>
        <example><![CDATA[
 public class JumbledIncrementerRule1 {
  public void foo() {
   for (int i = 0; i < 10; i++) {
    for (int k = 0; k < 20; i++) {
     System.out.println("Hello");
    }
   }
  }
 }
     ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
 //ForStatement
 [
  ForUpdate/StatementExpressionList/StatementExpression/PostfixExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
  =
  ancestor::ForStatement/ForInit//VariableDeclaratorId/@Image
 ]
             ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid empty switch statements" name="EmptySwitchStatements">
        <description>
      Avoid empty switch statements.
      </description>
        <example><![CDATA[
  public class Foo {
   public void bar() {
    int x = 2;
    switch (x) {
     // once there was code here
     // but it's been commented out or something
    }
   }
  }
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  //SwitchStatement[count(*) = 1]
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid instantiating Boolean objects; you can usually invoke Boolean.valueOf() instead." name="BooleanInstantiation">
        <description>
   Avoid instantiating Boolean objects, instead use Boolean.valueOf().
   </description>
        <example><![CDATA[
   
public class Foo {
 private Boolean bar = new Boolean("true"); // just do a Boolean bar = Boolean.TRUE or Boolean.valueOf(true);
}
   
   ]]></example>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

//AllocationExpression[not (ArrayDimsAndInits)
                       and
                       (Name/@Image='Boolean'
                       or
                       Name/@Image='java.lang.Boolean')]

              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.design.UseSingleton" message="All methods are static.  Consider using Singleton instead.  Alternatively, you could add a private constructor or make the class abstract to silence this warning." name="UseSingleton">
        <description>
    If you have a class that has nothing but static methods, consider making it a Singleton.
        Note that this doesn't apply to abstract classes, since their subclasses may
        well include non-static methods.  Also, if you want this class to be a Singleton,
        remember to add a private constructor to prevent instantiation.
    </description>
        <example><![CDATA[

public class MaybeASingleton {
    public static void foo() {
     // etc
    }
    public static void bar() {
     // etc
    }
}

    ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="When instantiating a SimpleDateFormat object, specify a Locale" name="SimpleDateFormatNeedsLocale">
        <description>
            Be sure to specify a Locale when creating a new instance of SimpleDateFormat.
        </description>
        <example><![CDATA[
        
    public class Foo {
     // Should specify Locale.US (or whatever)
     private SimpleDateFormat sdf = new SimpleDateFormat("pattern");
    }
        
        ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
        
    //AllocationExpression
     [Name[@Image='SimpleDateFormat']]
     [Arguments[@ArgumentCount=1]]
        
                    ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.UnusedFormalParameterRule" message="Avoid unused formal parameters such as ''{0}''" name="UnusedFormalParameter" symboltable="true">
        <description>
Avoid passing parameters to methods and then not using those parameters.
    </description>
        <example><![CDATA[

public class Foo {
 private void bar(String howdy) {
  // howdy is not used
 }

    ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Do not use 'if' statements that are always true or always false" name="UnconditionalIfStatement">
        <description>
      Do not use "if" statements that are always true or always false.
      </description>
        <example><![CDATA[
  public class Foo {
 public void close() {
  if (true) {
       // ...
   }
 }
}
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
 //IfStatement/Expression
 [count(PrimaryExpression)=1]
 /PrimaryExpression/PrimaryPrefix/Literal/BooleanLiteral
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid protected fields in a final class.  Change to private or package access." name="AvoidProtectedFieldInFinalClass">
        <description>
     Do not use protected fields in final classes since they cannot be subclassed.
    Clarify your intent by using private or package access modifiers instead.
         </description>
        <example><![CDATA[
     public final class Bar {
      private int x;
      protected int y;  // <-- Bar cannot be subclassed, so is y really private or package visible???
      Bar() {}
   }
         ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                     //ClassDeclaration[@Final='true']//FieldDeclaration[@Protected='true'] 
                 ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid throwing certain exception types." name="AvoidThrowingCertainExceptionTypes">
        <description>
 1) Avoid throwing certain exception types.  Rather than throw a raw RuntimeException, Throwable,
 Exception, or Error, use a subclassed exception or error instead.
 2) Avoid throwing a NullPointerException - it's confusing because most people will assume that the
 VM threw NPE.  Consider using InvalidArgumentException("Null parameter") which will be clearly seen as
a programmer initiated exception..  Use IllegalArgumentException or IllegalStateException instead.
    </description>
        <example><![CDATA[
      
throw new Exception();

    ]]></example>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
            
//AllocationExpression
 /Name[
 @Image='Throwable' |
 @Image='Exception' |
 @Image='Error' |
 @Image='RuntimeException' |
 @Image='NullPointerException']
 
        ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.optimization.MethodArgumentCouldBeFinal" message="A method argument that is not assigned could be declared final" name="MethodArgumentCouldBeFinal">
        <description>
      A method argumetn that is never assigned can be declared final.
      </description>
        <example><![CDATA[
  
  public void foo (String param) {
      // do stuff with param never assigning it
      // better: public void foo (final String param) {
  }
  
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid catching NullPointerException; consider removing the cause of the NPE." name="AvoidCatchingNPE">
        <description>
      Code should never throw NPE under normal circumstances.  A catch block may hide the original error, causing other more subtle errors in its wake.
    </description>
        <example><![CDATA[  
try {
  ...
} catch (NullPointerException npe) {
  ...
}

         ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
            
//TryStatement/FormalParameter/Type
 /Name[@Image='NullPointerException']
 
        ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.AvoidDeeplyNestedIfStmtsRule" message="Deeply nested if..then statements are hard to read" name="AvoidDeeplyNestedIfStmts">
        <description>
    Deeply nested if..then statements are hard to read.
    </description>
        <example><![CDATA[

public class Foo {
 public void bar() {
  int x=2;
  int y=3;
  int z=4;
  if (x>y) {
   if (y>z) {
    if (z==x) {
     // this is officially out of control now
    }
   }
  }
 }
}

    ]]></example>
        <priority>3</priority>
        <properties>
            <property name="problemDepth" value="3"/>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.optimization.AvoidInstantiatingObjectsInLoops" message="Avoid instantiating new objects inside loops" name="AvoidInstantiatingObjectsInLoops">
        <description>
Detects when a new object is created inside a loop
    </description>
        <example><![CDATA[

public class Something {
  public static void main( String as[] ) {  
    for (int i = 0; i < 10; i++) {
      Foo f = new Foo(); //Avoid this whenever you can it's really expensive
    }
  }
}

    ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.design.LongParameterListRule" message="Avoid really long parameter lists." name="ExcessiveParameterList">
        <description>
This checks to make sure that the Parameter Lists in the project aren't
getting too long.  If there are long parameter lists, then that is
generally indicative that another object is hiding around there.

Basically, try to group the parameters together.

Default value is 2.5 sigma greater than the mean.

NOTE:  In version 0.9 and higher, their are three parameters available:
minimum - Minimum Length before reporting.
sigma - Std Deviations away from the mean before reporting.
topscore - The Maximum Number of reports to generate.

At this time, only one can be used at a time.

   </description>
        <example><![CDATA[

public void addData(
  int p00, int p01, int p02, int p03, int p04, int p05,
  int p05, int p06, int p07, int p08, int p09, int p10) {

  }
}

   ]]></example>
        <priority>3</priority>
        <properties>
            <property name="minimum" value="10"/>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.design.NullAssignmentRule" message="Assigning an Object to null is a code smell.  Consider refactoring." name="NullAssignment">
        <description>
 Assigning a "null" to a variable (outside of its declaration) is usually in
 bad form.  Some times, the assignment is an indication that the programmer doesn't
 completely understand what is going on in the code.  NOTE: This sort of assignment
 may in rare cases be useful to encourage garbage collection.  If that's what you're using
 it for, by all means, disregard this rule :-)
      </description>
        <example><![CDATA[
 
 public class Foo {
   public void bar() {
     Object x = null; // This is OK.
     x = new Object();
     // Big, complex piece of code here.
     x = null; // This is BAD.
     // Big, complex piece of code here.
   }
 }

 
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid using 'if...else' statements without curly braces" name="IfElseStmtsMustUseBraces">
        <description>
       Avoid using if..else statements without using curly braces
       </description>
        <example><![CDATA[
   

     public void doSomething() {
       // this is OK
       if (foo) x++;

       // but this is not
       if (foo)
           x=x+1;
       else
           x=x-1;
     }
   
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

//Statement
 [parent::IfStatement[@Else='true']]
 [not(child::Block)]
 [not(child::IfStatement)]
 
                 ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid empty 'if' statements" name="EmptyIfStmt">
        <description>
  Empty If Statement finds instances where a condition is checked but nothing is done about it.
    </description>
        <example><![CDATA[
    if (foo == 0) {
       // why bother checking up on foo?
    }
       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  //IfStatement/Statement/Block[count(*) = 0]
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid instantiating String objects; this is usually unnecessary." name="StringInstantiation">
        <description>
    Avoid instantiating String objects; this is usually unnecessary.
    </description>
        <example><![CDATA[

public class Foo {
 private String bar = new String("bar"); // just do a String bar = "bar";
}

    ]]></example>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                   
    //AllocationExpression[Name/@Image='String'][count(.//Expression) < 2][not(ArrayDimsAndInits)]
                    
               ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid using 'while' statements without curly braces" name="WhileLoopsMustUseBraces">
        <description>
      Avoid using 'while' statements without using curly braces
      </description>
        <example><![CDATA[
  
    public void doSomething() {
      while (true)
          x++;
    }
  
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    
    //WhileStatement[not(Statement/Block)]
                    
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Don't use equals() to compare against null" name="EqualsNull">
        <description>
         Newbie programmers sometimes get the comparison concepts confused
         and use equals() to compare to null.
        </description>
        <example><![CDATA[
       
    class Bar {
       void foo() {
           String x = "foo";
           if (x.equals(null)) { // bad!
            doSomething();
           }
       }
    }
    
        ]]></example>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
    
    //PrimaryExpression
     [PrimaryPrefix/Name[ends-with(@Image, 'equals')]]
     [PrimarySuffix/Arguments/ArgumentList
      /Expression/PrimaryExpression/PrimaryPrefix
       /Literal/NullLiteral]
    
                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid excessively long variable names like {0}" name="LongVariable">
        <description>
Detects when a field, formal or local variable is declared with a long name.
    </description>
        <example><![CDATA[

public class Something {
  int reallyLongIntName = -3;  // VIOLATION - Field

  public static void main( String argumentsList[] ) { // VIOLATION - Formal
    int otherReallyLongName = -5; // VIOLATION - Local

    for (int interestingIntIndex = 0;  // VIOLATION - For
             interestingIntIndex < 10;
             interestingIntIndex ++ ) {

    }
}


    ]]></example>
        <priority>3</priority>
        <properties><!-- *changed* xpath from 12 to 20 -->
            <property name="xpath">
                <value><![CDATA[
                  
    //VariableDeclaratorId[string-length(@Image) > 20]
                  
              ]]></value>
            </property>
            <property name="pluginname" value="true"/>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid equality comparisons with Double.NaN" name="BadComparison">
        <description>
  Avoid equality comparisons with Double.NaN - these are
likely to be logic errors.
      </description>
        <example><![CDATA[
  
public class Bar {
int x = (y == Double.NaN);
}
  
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
//EqualityExpression[@Image='==']
 /PrimaryExpression/PrimaryPrefix
 /Name[@Image='Double.NaN' or @Image='Float.NaN']
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.CloseConnection" message="Ensures that Connection objects are always closed after use" name="CloseConnection">
        <description>
      Ensures that Connection objects are always closed after use
    </description>
        <example><![CDATA[
      
           public void foo() {
             Connection c = pool.getConnection();
             try {
               // do stuff
             } catch (SQLException ex) {
               // handle exception
             } finally {
               // oops, should close the connection using 'close'!
               // c.close();
             }
           }
  
    ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.ClassNamingConventions" message="Class names should begin with an uppercase character" name="ClassNamingConventions">
        <description> Class names should always begin with an upper case character.
      </description>
        <example><![CDATA[

public class Foo {}

      ]]></example>
        <priority>1</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.DoubleCheckedLocking" message="Double checked locking is not thread safe in Java." name="DoubleCheckedLocking">
        <description>
      Partially created objects can be returned by the Double Checked Locking pattern when used in Java.
      An optimizing JRE may assign a reference to the baz variable before it creates the object the
          reference is intended to point to.  For more details see http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html.
      </description>
        <example><![CDATA[
  public class Foo {
      Object baz;
      Object bar() {
        if(baz == null) { //baz may be non-null yet not fully created
          synchronized(this){
            if(baz == null){
              baz = new Object();
            }
          }
        }
        return baz;
      }
  }
      ]]></example>
        <priority>1</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid using short method names" name="ShortMethodName">
        <description>
Detects when very short method names are used.
     </description>
        <example><![CDATA[

public class ShortMethod {
  public void a( int i ) { // Violation
  }
}

     ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
    //MethodDeclarator[string-length(@Image) < 3]
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.optimization.LocalVariableCouldBeFinal" message="Local variable could be declared final" name="LocalVariableCouldBeFinal">
        <description>
      A local variable assigned only once can be declared final.
      </description>
        <example><![CDATA[
  
  public void foo () {
   String a = "a"; //if a will not be assigned again it is better to do this:
   final String b = "b";
   ...   
  }
  
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid variables with short names like {0}" name="ShortVariable">
        <description>
Detects when a field, local or parameter has a short name.
    </description>
        <example><![CDATA[

public class Something {
  private int q = 15; // VIOLATION - Field

  public static void main( String as[] ) {  // VIOLATION - Formal
    int r = 20 + q; // VIOLATION - Local

    for (int i = 0; i < 10; i++) { // Not a Violation (inside FOR)
      r += q;
    }
  }
}

    ]]></example>
        <priority>3</priority>
        <properties><!-- *changed* xpath from 3 to 2 -->
            <property name="xpath">
                <value><![CDATA[
                  
    //VariableDeclaratorId[string-length(@Image) < 2]
     [not(ancestor::ForInit)]
     [not((ancestor::FormalParameter) and (ancestor::TryStatement))]
                  
              ]]></value>
            </property>
            <property name="pluginname" value="true"/>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.AvoidConcatenatingNonLiteralsInStringBuffer" message="Avoid concatenating non literals in a StringBuffer constructor or append()" name="AvoidConcatenatingNonLiteralsInStringBuffer">
        <description>
    Avoid concatenating non literals in a StringBuffer constructor or append().
    </description>
        <example><![CDATA[


// Avoid this 
StringBuffer sb=new
StringBuffer("AAAAAAAAAA"+System.getProperty("java.io.tmpdir"));

// use instead something like this
StringBuffer sb = new StringBuffer("AAAAAAAAAA");
sb.append(System.getProperty("java.io.tmpdir"));


    ]]></example>
        <priority>2</priority>
        <properties/>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="System.out.println is used" name="SystemPrintln">
        <description>
     System.(out|err).println is used, consider using a logger.
     </description>
        <example><![CDATA[
 
class Foo{
    Logger log = Logger.getLogger(Foo.class.getName());

    public void testA () {
        System.out.println("Entering test");
        // Better use this
        log.fine("Entering test");
    }
}

     ]]></example>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                 
//Statement[
child:://Name[
    starts-with(@Image, 'System.out.print')
    or
    starts-with(@Image, 'System.err.print')
    ]
                
             ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Last statement in finalize method should be a call to super.finalize()" name="FinalizeDoesNotCallSuperFinalize">
        <description>
       If the finalize() is implemented, its last action should be to call super.finalize
       </description>
        <example><![CDATA[

public class Foo {
   protected void finalize() {
       something();
       // neglected to call super.finalize()
   }
}

       ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[


//MethodDeclaration[MethodDeclarator[@Image='finalize'][not(FormalParameters/*)]]
   /Block
      /BlockStatement[last()]
      [not(Statement/StatementExpression/PrimaryExpression/PrimaryPrefix[@Image='finalize'])]
      [not(Statement/TryStatement[@Finally='true']
       /Block/BlockStatement/Statement/StatementExpression
        /PrimaryExpression/PrimaryPrefix[@Image='finalize'])]

                ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Avoid empty synchronized blocks" name="EmptySynchronizedBlock">
        <description>
  Avoid empty synchronized blocks - they're useless.
      </description>
        <example><![CDATA[
  // this is bad
  public void bar() {
      synchronized (this) {}
  }
      ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  //SynchronizedStatement/Block[1][count(*) = 0]
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Switch statements should have a default label" name="SwitchStmtsShouldHaveDefault">
        <description>
    Switch statements should have a default label.
    </description>
        <example><![CDATA[

public class Foo {
 public void bar() {
  int x = 2;
  switch (x) {
   case 2: int j = 8;
  }
 }
}

    ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                  
    //SwitchStatement[not(SwitchLabel[count(*) = 0])]
                  
              ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.XPathRule" message="Finalize methods should not be overloaded" name="FinalizeOverloaded">
        <description>
   Methods named finalize() should not have parameters.  It is
   confusing and probably a bug to overload finalize().  It will
   not be called by the VM.
   </description>
        <example><![CDATA[

   public class Foo {
       // this is confusing and probably a bug
       protected void finalize(int a) {
       }
   }

   ]]></example>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[

//MethodDeclaration
 /MethodDeclarator[@Image='finalize'][FormalParameters[count(*)>0]]

            ]]></value>
            </property>
        </properties>
    </rule>
    <rule class="net.sourceforge.pmd.rules.design.ImmutableField" message="Private field could be made final.  It is only initialized in the declaration or constructor." name="ImmutableField" symboltable="true">
        <description>
      Identifies private fields whose values never change once they are initialized either in the declaration of the field or by
      a constructor.  This aids in converting existing classes to immutable classes.
      </description>
        <example><![CDATA[
  
  public class FinalFields {
      private int x;

      public FinalFields() {
          x = 7;
      }

      public void foo() {
         int a = x + 2;
      }

  }
  Identifies x as being eligible for making final.
  
      ]]></example>
        <priority>3</priority>
        <properties/>
    </rule>
</ruleset>
